<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1454021514082">{:repl-history {:ide [], :local [&quot;(ns rz.model.singular-linear)&quot; &quot;(:rotogrinder-events player)&quot; &quot;(defonce player (mc/find-one-as-map db c/*collection* {:Name \&quot;Andrew Wiggins\&quot;}))&quot; &quot;(:Name plater)&quot; &quot;(:Name player)&quot; &quot;(def player (mc/find-one-as-map db c/*collection* {:Name \&quot;Andrew Wiggins\&quot;}))&quot; &quot;(count (:rotogrinder-events player))&quot; &quot;(get-feature-set player)&quot; &quot;(draw-data player)&quot; &quot;(create-player-model player)&quot; &quot;(first (fix-pdata-keywords-draftking (init-players-data)))&quot; &quot;(first (data/init-players-data-draftking))&quot; &quot;(optimize-draftking-lineups)&quot; &quot;(mc/find-one-as-map db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } })&quot; &quot;(use '(monger operators))&quot; &quot;(:rotogrinder-events (mc/find-one-as-map db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } })\n  )&quot; &quot;(set (map :team-name (:rotogrinder-events (mc/find-one-as-map db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } }))))&quot; &quot;(set (map :team-name \n          (flatten \n            (map :rotogrinder-events (mc/find-maps db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } })))\n          ))&quot; &quot;(:rotogrinder-id (mc/find-one-as-map db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } }))&quot; &quot;(map :team-name (:rotogrinder-events (mc/find-one-as-map db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } })))&quot; &quot;(map :team-name (:rotogrinder-events (mc/find-one-as-map db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } })\n  ))&quot; &quot;(set (map :team-name (:rotogrinder-events (mc/find-one-as-map db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } })\n  )))&quot; &quot;(set (map :opp-name (:rotogrinder-events \n                       (second (mc/find-maps db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } }))\n  )))&quot; &quot;(set (map :team-name (:rotogrinder-events \n                       (second (mc/find-maps db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } }))\n  )))&quot; &quot;(count (set (map :team-name (:rotogrinder-events \n                       (second (mc/find-maps db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } }))\n  ))))&quot; &quot;(count (set (map :opp-name (:rotogrinder-events \n                       (second (mc/find-maps db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } }))\n  ))))&quot; &quot;(rotoscrap/ingest-player-info \n  db\n  (mc/find-one-as-map db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } })\n  )&quot; &quot;(map :team-name (:rotogrinder-events\n  (mc/find-one-as-map db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } })\n  ))&quot; &quot;(map :opp-name (:rotogrinder-events\n  (mc/find-one-as-map db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } })\n  ))&quot; &quot;(rotoscrap/ingest-data \n  db\n  (mc/find-one-as-map db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } })\n  )&quot; &quot;(map :team-name (:rotogrinder-events\n  (second (mc/find-maps db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } }))\n  ))&quot; &quot;(linear/create-model)&quot; &quot;(linear/create-model db)&quot; &quot;(set (map :team-name \n  (map :rotogrinder-events (mc/find-maps db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } }))\n  ))&quot; &quot;(set (map :team-name \n  (flatten (map :rotogrinder-events (mc/find-maps db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } })))\n  ))&quot; &quot;(count *1)&quot; &quot;(set (map :opp-name \n  (flatten (map :rotogrinder-events (mc/find-maps db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } })))\n  ))&quot; &quot;(sort (set (map :team-name \n  (flatten (map :rotogrinder-events (mc/find-maps db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } })))\n  )))&quot; &quot;(sort (set (map :opp-name \n  (flatten (map :rotogrinder-events (mc/find-maps db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } })))\n  )))&quot; &quot;(linear/create-model db c/*fanduel*)&quot; &quot;(ns rz.model.linear)&quot; &quot;(create-array-for-regression (filter-23 (prepare-data-for-regression-recursive db :fanduel-fpts)))&quot; &quot;(create-model db c/*fanduel*)&quot; &quot;(create-svm-model)&quot; &quot;(create-svm-model db)&quot; &quot;(create-array-for-regression\n  (linear/filter-23 (linear/prepare-data-for-regression-recursive db :fanduel-fpts))\n  :fanduel-fpts\n  )&quot; &quot;(ns rz.model.svm)&quot; &quot;(def ftps-keyword :fanduel-fpts)&quot; &quot;(first (linear/filter-23 (linear/prepare-data-for-regression-recursive db ftps-keyword)))&quot; &quot;(reverse [1 2 3])&quot; &quot;(+ 2 2)&quot; &quot;(partition-by #())&quot; &quot;(rand)&quot; &quot;(partition-by #(&gt; (rand) 0.5))&quot; &quot;(partition-by #(&gt; (rand) 0.5) [1 2 3 4 5])&quot; &quot;(partition-by (fn [x] (&gt; (rand) 0.5)) [1 2 3 4 5])&quot; &quot;(take 10 (rand))&quot; &quot;(take 10 (repeatedly (rand)))&quot; &quot;(take 10 (repeatedly rand))&quot; &quot;(partition-by (fn [x] (&lt; (rand) 0.5)) [1 2 3 4 5])&quot; &quot;(partition-by (fn [x] (&lt;= (rand) 0.5)) [1 2 3 4 5])&quot; &quot;(repeatedly 2 #(rand-nth [2 3 4 5 6 7]))&quot; &quot;()&quot; &quot;(rz.model.linear/create-model db c/*fanduel*)&quot; &quot;(create-svm-model db c/*fanduel*)&quot; &quot;(ns rz.optimizer)&quot; &quot;(svm/create-svm-model db c/*fanduel*)&quot; &quot;(slurp svm/*svm-test-output-file*)&quot; &quot;(split-lines (slurp svm/*svm-test-output-file*))&quot; &quot;(clojure.string/split-lines (slurp svm/*svm-test-output-file*))&quot; &quot;(first (clojure.string/split-lines (slurp svm/*svm-test-output-file*)))&quot; &quot;(read-string (first (clojure.string/split-lines (slurp svm/*svm-test-output-file*))))&quot; &quot;(rotoscrap/ingest-data c/*fanduel*)&quot; &quot;db&quot; &quot;(def players-proj (model/add-linear-projection db players-data {} c/*fanduel* svm/svm-proj))&quot; &quot;(map #(println (str \&quot;1: \&quot; %1 \&quot;, 2: \&quot; %2)) [:a :b :c] [:x :y :z])&quot; &quot;(optimize-fanduel-lineups-svm)&quot; &quot;players-data&quot; &quot;(first players-data)&quot; &quot;(def {:keys [Name]} (data/init-players-data-fanduel))&quot; &quot;(def {:keys [Name]} (first players-data))&quot; &quot;(def Name (:Name (mc/find-one-as-map db c/*collection* {:Name Name})]))&quot; &quot;(:Name (first players-data))&quot; &quot;(def db (utils/get-db))&quot; &quot;(mc/find-one-as-map db c/*collection* {:Name \&quot;Stephen Curry\&quot;})&quot; &quot;(def dbpinfo *1)&quot; &quot;(:rotogrinder-events dbpinfo)&quot; &quot;(def rotogrinder-events (:rotogrinder-events dbpinfo))&quot; &quot;(model/predict-data-from-events\n  \&quot;SS\&quot; (sort-by :game-epoch rotogrinder-events) :fanduel-fpts)&quot; &quot;((create-array-for-regression \n   [(model/predict-data-from-events\n  \&quot;SS\&quot; (sort-by :game-epoch rotogrinder-events) :fanduel-fpts)])&quot; &quot;(create-array-for-regression \n   [(model/predict-data-from-events\n  \&quot;SS\&quot; (sort-by :game-epoch rotogrinder-events) :fanduel-fpts)])&quot; &quot;(svm/create-array-for-regression \n   [(model/predict-data-from-events\n  \&quot;SS\&quot; (sort-by :game-epoch rotogrinder-events) :fanduel-fpts)])&quot; &quot;(svm/create-array-for-regression \n   [(model/predict-data-from-events\n  \&quot;SS\&quot; (sort-by :game-epoch rotogrinder-events) :fanduel-fpts)]\n   :fanduel-fpts)&quot; &quot;(def pdata [(model/predict-data-from-events\n              \&quot;SS\&quot; (sort-by :game-epoch rotogrinder-events) :fanduel-fpts)])&quot; &quot;(keys pdata)&quot; &quot;(keys (first pdata))&quot; &quot;(:pts-current (first pdata))&quot; &quot;(optimize-fanduel-lineups)&quot; &quot;(def db (utils/get-db)\n  )&quot; &quot;(def players-data (data/init-players-data-fanduel))&quot; &quot;(svm/predict-players db players-data c/*fanduel*)&quot;], :remote []}}</component>
</project>