<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1453935742967">{:repl-history {:ide [], :local [&quot;(lpsolve-solve-draftkings)&quot; &quot;(ns rz.scrap.rotogrinder)&quot; &quot;(ingest-data)&quot; &quot;(mc/find-one-as-map db c/*collection* {:Name \&quot;Wilson Chandler\&quot;})&quot; &quot;(mc/find-one-as-map db c/*collection* {:Name \&quot;Wilson Chandler\&quot;, :rotogrinder-events { $exists: true, $not: {$size: 0} } })&quot; &quot;(mc/find-one-as-map db c/*collection* {:Name \&quot;Wilson Chandler\&quot;, :rotogrinder-events { $exists true $not {$size 0} } })&quot; &quot;(let [{:keys [Name rotogrinder-events teamAbbrev]} (mc/find-one-as-map db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } })\n      sorted-events (sort-by :game-epoch rotogrinder-events)\n      event-current (last sorted-events)\n      events (butlast sorted-events)\n      event-last (last events)\n      home-events (filter #(= true (:home-game %)) sorted-events)\n      away-events (filter #(= false (:home-game %)) sorted-events)\n\n      iterations (- (min (count home-events) (count away-events)) c/*average-games-count*)\n      ]\n  [(count home-events) (count away-events) (count rotogrinder-events)]\n  rotogrinder-events\n  )&quot; &quot;(let [{:keys [Name rotogrinder-events teamAbbrev]} (mc/find-one-as-map db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } })\n      sorted-events (sort-by :game-epoch rotogrinder-events)\n      event-current (last sorted-events)\n      events (butlast sorted-events)\n      event-last (last events)\n      home-events (filter #(= true (:home-game %)) sorted-events)\n      away-events (filter #(= false (:home-game %)) sorted-events)\n\n      iterations (- (min (count home-events) (count away-events)) c/*average-games-count*)\n      ]\n  iterations\n  )&quot; &quot;(count (create-array-for-regression (filter-23 (prepare-data-for-regression db))))&quot; &quot;(range 1 10)&quot; &quot;(conj 2 [2 3 4])&quot; &quot;(conj [2 3 4] 2)&quot; &quot;(conj [2 3 4] 5)&quot; &quot;(prepare-data-for-regression-recursive db)&quot; &quot;(flatten (prepare-data-for-regression-recursive db))&quot; &quot;(count (prepare-data-for-regression-recursive db))&quot; &quot;db&quot; &quot;(prepare-data-for-regression db)&quot; &quot;(split (range 10))&quot; &quot;(shell/sh \&quot;ls\&quot;)&quot; &quot;(create-svm-model)&quot; &quot;(def out *1)&quot; &quot;(keys out)&quot; &quot;(count *1)&quot; &quot;(create-svm-model db)&quot; &quot;(rotoscrap/ingest-data)&quot; &quot;(rz.scrap.rotogrinder/ingest-data)&quot; &quot;(first (data/init-players-data-fanduel))&quot; &quot;(count (mc/find-maps db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } }))&quot; &quot;(svm/create-svm-model (utils/get-db))&quot; &quot;(create-model)&quot; &quot;(create-model db)&quot; &quot;(def db (utils/get-db))&quot; &quot;(def coefs (linear/create-model db))&quot; &quot;(def players-data (data/init-players-data-fanduel))&quot; &quot;(linear/add-linear-projection db players-data coefs)&quot; &quot;(def a {:a 2})&quot; &quot;a&quot; &quot;(def kw :a)&quot; &quot;kw&quot; &quot;(kw a)&quot; &quot;(def ftps-keyword :fanduel-fpts)&quot; &quot;(last (prepare-data-for-regression-recursive db ftps-keyword))&quot; &quot;(mc/find-one-as-map db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } })&quot; &quot;(last (:rotogrinder-events (mc/find-one-as-map db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } })))&quot; &quot;(rotoscrap/ingest-data c/*fanduel*)&quot; &quot;(map #(list (:draftking-fpts %) (:fanduel-fpts %)) (:rotogrinder-events (mc/find-one-as-map db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } })))&quot; &quot;(ns rz.optimizer)&quot; &quot;(coinmp/lpsolve-solve-fanduel)&quot; &quot;coefs&quot; &quot;(linear/add-linear-projection db players-data coefs c/*fanduel*)&quot; &quot;(first players-data)&quot; &quot;(pp/pprint (first players-data))&quot; &quot;(data/fix-pdata-keywords-fanduel)&quot; &quot;(data/init-players-data-fanduel)&quot; &quot;(last (data/init-players-data-fanduel))&quot; &quot;(use [monger operators])&quot; &quot;(use '(monger operators))&quot; &quot;(map (comp count :rotogrinder-events ) (mc/find-maps db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } }))&quot; &quot;(apply min\n       (map (comp count :rotogrinder-events ) (mc/find-maps db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } })))&quot; &quot;(apply max\n       (map (comp count :rotogrinder-events ) (mc/find-maps db c/*collection* {:rotogrinder-events { $exists true $not {$size 0} } })))&quot; &quot;(mc/find-one-as-map db c/*collection* {:rotogrinder-events { $exists true $not {$size 82} } })&quot; &quot;(mc/find-one-as-map db c/*collection* {:rotogrinder-events { $exists true $eq {$size 82} } })&quot; &quot;(mc/find-one-as-map db c/*collection* {:rotogrinder-events { $exists true $gt {$size 82} } })&quot; &quot;(count (:rotogrinder-events (mc/find-one-as-map db c/*collection* {:rotogrinder-events { $exists true $gt {$size 82} } })))&quot; &quot;(count (:rotogrinder-events (mc/find-one-as-map db c/*collection* {:rotogrinder-events  {$size 82} })))&quot; &quot;(:Name player)&quot; &quot;(:Team player)&quot; &quot;(v)&quot; &quot;(optimize-fanduel-lineups)&quot; &quot;(linear/create-model db c/*fanduel*)&quot; &quot;incanter.stats/linear-model&quot; &quot;incanter.stats/view&quot; &quot;incanter.io/view&quot; &quot;incanter.core/view&quot; &quot;(draw-data)&quot; &quot;(ns rz.model.linear)&quot; &quot;(draw-data db c/*fanduel* (create-model db c/*fanduel*))&quot; &quot;(def player (mc/find-one-as-map db c/*collection* {:rotogrinder-events  {$size 82} }))&quot; &quot;player&quot; &quot;(:rotogrinder-events player)&quot; &quot;(let [{:keys [rotogrinder-events]} player\n      sorted-events (sort-by :game-epoch rotogrinder-events)\n      butlast-events (butlast sorted-events)\n      home-events (filter #(= true (:home-game %)) butlast-events)\n      away-events (filter #(= false (:home-game %)) butlast-events)\n      iterations-cnt (- (min (count home-events) (count away-events)) c/*average-games-count*)\n      ]\n\n  iterations-cnt\n  )&quot; &quot;(let [{:keys [rotogrinder-events]} player\n      sorted-events (sort-by :game-epoch rotogrinder-events)\n      butlast-events (butlast sorted-events)\n      home-events (filter #(= true (:home-game %)) butlast-events)\n      away-events (filter #(= false (:home-game %)) butlast-events)\n      iterations-cnt (- (min (count home-events) (count away-events)) c/*average-games-count*)\n      tdata-from-events (fn [history current]\n                          [(utils/array-&gt;mean (map :fanduel-fpts history))\n                           (utils/array-&gt;mean (take-last c/*average-games-count* (map :fanduel-fpts history)))\n                           (:fanduel-fpts (last history))\n                           (:home-game current)\n                           (:fanduel-fpts current)]\n                          )]\n  (loop [iteration 0\n         events sorted-events\n         result []]\n    (if (&gt; iteration iteration-cnt)\n      result\n      (recur (inc iteration) (butlast event) (conj result (tdata-from-events (butlast event) (last event)))))\n    )\n  \n  )&quot; &quot;(let [{:keys [rotogrinder-events]} player\n      sorted-events (sort-by :game-epoch rotogrinder-events)\n      butlast-events (butlast sorted-events)\n      home-events (filter #(= true (:home-game %)) butlast-events)\n      away-events (filter #(= false (:home-game %)) butlast-events)\n      iterations-cnt (- (min (count home-events) (count away-events)) c/*average-games-count*)\n      tdata-from-events (fn [history current]\n                          [(utils/array-&gt;mean (map :fanduel-fpts history))\n                           (utils/array-&gt;mean (take-last c/*average-games-count* (map :fanduel-fpts history)))\n                           (:fanduel-fpts (last history))\n                           (:home-game current)\n                           (:fanduel-fpts current)]\n                          )]\n  (loop [iteration 0\n         events sorted-events\n         result []]\n    (if (&gt; iteration iterations-cnt)\n      result\n      (recur (inc iteration) (butlast event) (conj result (tdata-from-events (butlast event) (last event)))))\n    )\n  \n  )&quot; &quot;(let [{:keys [rotogrinder-events]} player\n      sorted-events (sort-by :game-epoch rotogrinder-events)\n      butlast-events (butlast sorted-events)\n      home-events (filter #(= true (:home-game %)) butlast-events)\n      away-events (filter #(= false (:home-game %)) butlast-events)\n      iterations-cnt (- (min (count home-events) (count away-events)) c/*average-games-count*)\n      tdata-from-events (fn [history current]\n                          [(utils/array-&gt;mean (map :fanduel-fpts history))\n                           (utils/array-&gt;mean (take-last c/*average-games-count* (map :fanduel-fpts history)))\n                           (:fanduel-fpts (last history))\n                           (:home-game current)\n                           (:fanduel-fpts current)]\n                          )]\n  (loop [iteration 0\n         events sorted-events\n         result []]\n    (if (&gt; iteration iterations-cnt)\n      result\n      (recur (inc iteration) (butlast events) (conj result (tdata-from-events (butlast events) (last events)))))\n    )\n  \n  )&quot; &quot;(ns rz.model.singular-linear)&quot; &quot;get-feature-set&quot; &quot;(get-feature-set)&quot; &quot;points&quot; &quot;(get-feature-set player)&quot; &quot;(create-player-model player)&quot; &quot;(def c *1)&quot; &quot;(concat 1 c)&quot; &quot;(conj 1 c)&quot; &quot;(cons 1 c)&quot; &quot;(def points (get-feature-set player))&quot; &quot;(first points)&quot; &quot;(cons 1 (first points))&quot; &quot;(cons 1 (but-last (first points)))&quot; &quot;(cons 1 (butlast (first points)))&quot; &quot;(draw-data player)&quot;], :remote []}}</component>
</project>